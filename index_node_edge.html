<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gene Statement Counts + Gene Network</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<!-- vis-network for the gene social graph -->
<script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
<link href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css" rel="stylesheet" />

<style>
  #network {
    width: 100%;
    height: 600px;
    border: 2px solid #ddd;
    margin-top: 40px;
  }
</style>
</head>

<body>

<h2>How Often Alzheimer-associated Genes Are Mentioned in Wikidata</h2>

<div id="chart-wrapper">
  <canvas id="geneChart" width="800" height="400"></canvas>
</div>

<h2>Alzheimer Gene Social Network (Shared Disease Connections)</h2>
<div id="network"></div>

<script>
// =============================================================
// 1. FETCH GENE STATEMENT COUNTS (your existing bar chart code)
// =============================================================
async function fetchGeneTraitData() {
    const endpointUrl = "https://query.wikidata.org/sparql";

    const query = `
    SELECT ?gene ?geneLabel (COUNT(?p) AS ?statementCount)
    WHERE {
      ?gene wdt:P2293 wd:Q11081 .
      ?gene ?p ?o .
      FILTER(STRSTARTS(STR(?p), "http://www.wikidata.org/prop/direct/"))
      SERVICE wikibase:label { bd:serviceParam wikibase:language "en" }
    }
    GROUP BY ?gene ?geneLabel
    ORDER BY DESC(?statementCount)
    `;

    const url = endpointUrl + "?query=" + encodeURIComponent(query) + "&format=json";

    try {
        const response = await fetch(url, {
            headers: { 'Accept': 'application/sparql-results+json' }
        });

        const data = await response.json();

        return data.results.bindings.map(item => ({
            gene: item.geneLabel.value,
            count: parseInt(item.statementCount.value)
        }));

    } catch (error) {
        console.error("Error fetching data:", error);
        return [];
    }
}

async function plotGeneData() {
    const data = await fetchGeneTraitData();

    const labels = data.map(item => item.gene);
    const counts = data.map(item => item.count);

    const ctx = document.getElementById('geneChart').getContext('2d');

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Number of Wikidata Statements',
                data: counts,
                backgroundColor: '#ff4fa3',
                borderColor: '#b1005a',
                borderWidth: 2,
                hoverBackgroundColor: '#ff94c9'
            }]
        },
        options: {
            responsive: true,
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: "Statement Count" }
                },
                x: {
                    title: { display: true, text: "Gene" }
                }
            }
        }
    });
}

plotGeneData();


// =============================================================
// 2. FETCH GENE–GENE NETWORK (WORKING SPARQL QUERY)
// =============================================================
async function fetchGeneNetwork() {
    const endpointUrl = "https://query.wikidata.org/sparql";

    const query = `
    SELECT ?gene1Label ?gene2Label (COUNT(?disease) AS ?weight) WHERE {
      ?gene1 wdt:P2293 wd:Q11081 .
      ?gene2 wdt:P2293 wd:Q11081 .
      FILTER(?gene1 != ?gene2)
      ?gene1 wdt:P2293 ?disease .
      ?gene2 wdt:P2293 ?disease .
      FILTER(?disease != wd:Q11081)
      SERVICE wikibase:label { bd:serviceParam wikibase:language "en" }
    }
    GROUP BY ?gene1Label ?gene2Label
    HAVING (COUNT(?disease) > 0)
    ORDER BY DESC(?weight)
    `;

    const url = endpointUrl + "?query=" + encodeURIComponent(query) + "&format=json";

    const response = await fetch(url, {
        headers: { "Accept": "application/sparql-results+json" }
    });

    const raw = await response.json();

    const nodes = new Map();
    const edgeMap = new Map();

    raw.results.bindings.forEach(row => {
        const g1 = row.gene1Label.value;
        const g2 = row.gene2Label.value;
        const weight = parseInt(row.weight.value);

        // Register nodes
        nodes.set(g1, { id: g1, label: g1 });
        nodes.set(g2, { id: g2, label: g2 });

        // Create a sorted key so APOE–APP and APP–APOE become the same
        const key = [g1, g2].sort().join("__");

        // Keep the maximum weight for the pair
        if (!edgeMap.has(key)) {
            edgeMap.set(key, {
                from: g1,
                to: g2,
                value: weight,
                title: `${weight} shared diseases`
            });
        } else {
            // If reversed version is found, store the larger weight
            const existing = edgeMap.get(key);
            if (weight > existing.value) {
                existing.value = weight;
                existing.title = `${weight} shared diseases`;
            }
        }
    });

    // Convert merged edges to array
    const edges = Array.from(edgeMap.values());

    drawNetwork([...nodes.values()], edges);
}


// =============================================================
// 3. DRAW NETWORK USING VIS-NETWORK
// =============================================================
function drawNetwork(nodes, edges) {
    const container = document.getElementById("network");

    const data = {
        nodes: new vis.DataSet(nodes),
        edges: new vis.DataSet(edges)
    };

    const options = {
        nodes: {
            shape: "dot",
            size: 15,
            color: "#ff4fa3",
            borderWidth: 2
        },
        edges: {
            scaling: { min: 1, max: 15 },
            color: { color: "#b1005a" },
            smooth: true
        },
        physics: {
            stabilization: true
        }
    };

    new vis.Network(container, data, options);
}

// Run network fetch
fetchGeneNetwork();
</script>

</body>
</html>
